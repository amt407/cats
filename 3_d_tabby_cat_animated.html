<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Tabby Cat – animated</title>
  <style>
    html,body{height:100%;margin:0;background:#e8eef4;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    #app{position:fixed;inset:0}
    .hud{position:fixed;left:12px;bottom:12px;background:#ffffffcc;border-radius:12px;padding:10px 12px;box-shadow:0 6px 18px rgba(0,0,0,.15);backdrop-filter:saturate(1.4) blur(6px);}
    .hud b{display:block;margin-bottom:6px}
    .btn{display:inline-block;border:0;background:#111;color:#fff;border-radius:10px;padding:8px 12px;cursor:pointer}
    .row{display:flex;gap:8px;align-items:center}
    .kbd{font:12px/1.2 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;background:#f3f3f6;border:1px solid #d7d7de;border-bottom-width:2px;border-radius:6px;padding:2px 6px}
  </style>
</head>
<body>
  <div id="app"></div>
  <div class="hud">
    <b>Controls</b>
    <div class="row"><button class="btn" id="toggle">Toggle Walk (Space)</button><span class="kbd">Drag</span> to orbit</div>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';

    const scene = new THREE.Scene();
    scene.background = new THREE.Color('#e8eef4');

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.shadowMap.enabled = true;
    document.getElementById('app').appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 100);
    camera.position.set(4.2, 2.2, 4.6);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.minDistance = 2.0; controls.maxDistance = 12.0;
    controls.target.set(0, 0.75, 0);

    // Lights
    const hemi = new THREE.HemisphereLight(0xffffff, 0x667788, 0.8);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 1.15);
    dir.position.set(4, 6, 3);
    dir.castShadow = true;
    dir.shadow.mapSize.set(2048,2048);
    scene.add(dir);

    // Ground
    const groundGeo = new THREE.CircleGeometry(8, 64);
    const groundMat = new THREE.MeshStandardMaterial({ color: 0xf7f7f9, roughness: 0.95, metalness: 0.0 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotateX(-Math.PI/2);
    ground.receiveShadow = true;
    scene.add(ground);

    // Helper: create a simple tabby texture procedurally on a canvas
    function makeTabbyTexture(base='#9b7a4f'){
      const c = document.createElement('canvas');
      c.width = c.height = 512; const ctx = c.getContext('2d');
      // base coat
      const grd = ctx.createLinearGradient(0,0,512,512);
      grd.addColorStop(0,'#b08b5e'); grd.addColorStop(1,'#8e6f48');
      ctx.fillStyle = grd; ctx.fillRect(0,0,512,512);
      // stripes
      ctx.strokeStyle = '#3b2c1d';
      ctx.globalAlpha = 0.35; ctx.lineWidth = 24; ctx.lineCap='round';
      for(let i=0;i<10;i++){
        const y = 40 + i*46;
        ctx.beginPath();
        ctx.moveTo(20, y);
        for(let x=20;x<520;x+=40){
          const amp = 14 + (i%2?10:0);
          ctx.quadraticCurveTo(x+20, y+amp, x+40, y);
        }
        ctx.stroke();
      }
      // speckles
      ctx.globalAlpha = 0.25; ctx.fillStyle = '#2a2016';
      for(let i=0;i<1300;i++){
        const x = Math.random()*512, y = Math.random()*512, r = Math.random()*1.2;
        ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
      }
      const tex = new THREE.CanvasTexture(c);
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      tex.repeat.set(1.6, 0.9);
      return tex;
    }

    const tabbyTex = makeTabbyTexture();

    // Materials
    const fur = new THREE.MeshStandardMaterial({ map: tabbyTex, roughness: 0.9, metalness: 0.0 });
    const furDark = new THREE.MeshStandardMaterial({ color: 0x5a452d, roughness: 0.9 });
    const furLight = new THREE.MeshStandardMaterial({ color: 0xd8b88a, roughness: 0.95 });
    const eyeGreen = new THREE.MeshStandardMaterial({ color: 0x88aa66, metalness: 0.1, roughness: 0.3 });
    const nosePink = new THREE.MeshStandardMaterial({ color: 0xd88f7a, roughness: 0.5 });

    // Build a simple low-poly cat from primitives
    const cat = new THREE.Group();

    // Body (capsule)
    const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.55, 1.2, 6, 16), fur);
    body.rotation.z = Math.PI/2 * 0.06;
    body.position.y = 0.9;
    body.castShadow = true; body.receiveShadow = true;
    cat.add(body);

    // Neck
    const neck = new THREE.Mesh(new THREE.CylinderGeometry(0.22, 0.28, 0.35, 16), fur);
    neck.position.set(0.55, 1.25, 0);
    neck.rotation.z = Math.PI/2 * 0.12;
    neck.castShadow = true; cat.add(neck);

    // Head
    const head = new THREE.Group();
    const skull = new THREE.Mesh(new THREE.SphereGeometry(0.42, 22, 22), fur);
    skull.castShadow = true; head.add(skull);

    // Muzzle
    const muzzle = new THREE.Mesh(new THREE.SphereGeometry(0.24, 20, 20), furLight);
    muzzle.position.set(0.15,-0.02,0);
    head.add(muzzle);
    const nose = new THREE.Mesh(new THREE.ConeGeometry(0.06, 0.1, 12), nosePink);
    nose.rotation.z = Math.PI/2; nose.position.set(0.26, -0.02, 0);
    head.add(nose);

    // Eyes
    function makeEye(side=1){
      const eye = new THREE.Group();
      const globe = new THREE.Mesh(new THREE.SphereGeometry(0.09, 18, 18), eyeGreen);
      globe.position.set(0.1, 0, 0);
      const pupil = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.012, 0.06, 12), new THREE.MeshStandardMaterial({color:0x111111, metalness:0.2, roughness:0.3}));
      pupil.rotation.z = Math.PI/2; pupil.position.set(0.18,0,0);
      const lid = new THREE.Mesh(new THREE.SphereGeometry(0.091, 18, 18, 0, Math.PI*2, 0, Math.PI/2), furLight);
      lid.visible = true; lid.position.copy(globe.position); lid.userData._blink = 0; // 0=open
      eye.add(globe,pupil,lid);
      eye.position.set(0.22, 0.06, side*0.17);
      return eye;
    }
    const leftEye = makeEye(1), rightEye = makeEye(-1);
    head.add(leftEye,rightEye);

    // Ears
    function makeEar(side=1){
      const ear = new THREE.Group();
      const outer = new THREE.Mesh(new THREE.ConeGeometry(0.22, 0.42, 4), furDark);
      outer.rotation.z = Math.PI; outer.position.y = 0.18;
      const inner = new THREE.Mesh(new THREE.ConeGeometry(0.16, 0.34, 4), new THREE.MeshStandardMaterial({color:0xe7c1a5, roughness:0.9}));
      inner.rotation.z = Math.PI; inner.position.set(0,0.2,0);
      ear.add(outer, inner);
      ear.position.set(-0.12, 0.35, side*0.23);
      return ear;
    }
    const leftEar = makeEar(1), rightEar = makeEar(-1);
    head.add(leftEar,rightEar);

    head.position.set(0.85, 1.42, 0);
    cat.add(head);

    // Legs (simple two-segment for subtle gait)
    function makeLeg(){
      const upper = new THREE.Mesh(new THREE.CapsuleGeometry(0.16, 0.24, 6, 12), fur);
      const lower = new THREE.Mesh(new THREE.CapsuleGeometry(0.14, 0.26, 6, 12), fur);
      const paw = new THREE.Mesh(new THREE.SphereGeometry(0.16, 16, 16), furLight);
      const jnt = new THREE.Group();
      upper.castShadow = lower.castShadow = paw.castShadow = true;
      lower.position.y = -0.35; paw.position.y = -0.68;
      jnt.add(upper); jnt.add(lower); jnt.add(paw);
      jnt.userData.lower = lower; jnt.userData.paw = paw;
      return jnt;
    }

    const FL = makeLeg(); FL.position.set(0.25, 0.86, 0.28);
    const FR = makeLeg(); FR.position.set(0.25, 0.86,-0.28);
    const BL = makeLeg(); BL.position.set(-0.55,0.86, 0.28);
    const BR = makeLeg(); BR.position.set(-0.55,0.86,-0.28);
    cat.add(FL,FR,BL,BR);

    // Tail (chain)
    const tail = new THREE.Group();
    let prev = tail;
    const segments = [];
    for(let i=0;i<6;i++){
      const seg = new THREE.Mesh(new THREE.CapsuleGeometry(0.12-(i*0.014), 0.24, 6, 10), furDark);
      seg.castShadow = true;
      const pivot = new THREE.Group();
      pivot.add(seg);
      seg.position.x = 0.2;
      pivot.position.x = i===0? -0.95 : 0.2;
      pivot.position.y = 1.2 - (i*0.02);
      pivot.position.z = 0;
      prev.add(pivot);
      prev = pivot; segments.push(pivot);
    }
    cat.add(tail);

    scene.add(cat);

    // Subtle shadow catcher underneath the cat for depth
    const shadowGeo = new THREE.PlaneGeometry(2.6, 2.6);
    const shadowMat = new THREE.ShadowMaterial({ opacity: 0.25 });
    const shadowMesh = new THREE.Mesh(shadowGeo, shadowMat);
    shadowMesh.receiveShadow = true; shadowMesh.rotateX(-Math.PI/2); shadowMesh.position.y = 0.001;
    scene.add(shadowMesh);

    // Animation state
    let t = 0; let walk = false; let blinkTimer = 0;

    function animate(){
      requestAnimationFrame(animate);
      const dt = Math.min(0.033, renderer.info.render.frame/1000) || 0.016;
      t += 0.016; // fixed timestep for consistency

      // Head follows mouse (via controls target)
      head.lookAt(camera.position.x*0.25, 1.3, camera.position.z*0.25);

      // Tail sway
      const sway = Math.sin(t*2.2)*0.35 + Math.sin(t*0.7)*0.12;
      segments.forEach((p,i)=>{ p.rotation.z = sway * (1 - i*0.12); });

      // Breathing
      body.scale.y = 1 + Math.sin(t*1.2)*0.015;

      // Ear twitch occasionally
      const tw = Math.sin(t*9.0)*0.06; leftEar.rotation.x = tw; rightEar.rotation.x = -tw*0.8;

      // Blinking (animate eyelids by scaling their polar angle – fake via y-scale)
      blinkTimer -= 0.016; if(blinkTimer <= 0){ blinkTimer = 2 + Math.random()*3; leftEye.children[2].scale.y = 1.4; rightEye.children[2].scale.y = 1.4; }
      leftEye.children[2].scale.y += (1 - leftEye.children[2].scale.y)*0.2;
      rightEye.children[2].scale.y += (1 - rightEye.children[2].scale.y)*0.2;

      if(walk){
        const s = Math.sin(t*4.0), c = Math.cos(t*4.0);
        const amp = 0.65;
        FL.rotation.x =  amp*s; FR.rotation.x = -amp*s; // alternate
        BL.rotation.x = -amp*s; BR.rotation.x =  amp*s;
        // lower leg counter-rotation for knee bend
        FL.userData.lower.rotation.x = -amp*0.6*s; FR.userData.lower.rotation.x =  amp*0.6*s;
        BL.userData.lower.rotation.x =  amp*0.6*s; BR.userData.lower.rotation.x = -amp*0.6*s;
        // body bob
        cat.position.y = 0.06 + Math.abs(s)*0.06;
        cat.position.x = Math.sin(t*2.0)*0.04;
      } else {
        // idle pose
        FL.rotation.x = FR.rotation.x = BL.rotation.x = BR.rotation.x = 0;
        FL.userData.lower.rotation.x = FR.userData.lower.rotation.x = BL.userData.lower.rotation.x = BR.userData.lower.rotation.x = 0;
        cat.position.y = 0;
      }

      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // Resize
    addEventListener('resize', ()=>{ renderer.setSize(innerWidth, innerHeight); camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); });

    // Toggle walk
    const btn = document.getElementById('toggle');
    btn.addEventListener('click', ()=> walk = !walk );
    window.addEventListener('keydown', (e)=>{ if(e.code === 'Space'){ e.preventDefault(); walk = !walk; }});

    // Make cat cast/receive shadows
    cat.traverse(o=>{ if(o.isMesh){ o.castShadow = true; o.receiveShadow = o.material === groundMat ? true : false; } });
  </script>
</body>
</html>
